# 项目简介

### 1.起步
一个简短的IM应用，一步步实现从最基础到分布式版本

#### 1.1版本
采用Socket搭配ServerSocket进行网络编程，SpringBoot应用启动后，SingleExecutorService开启独立线程循环accept到Socket连接。
然后向线程池中提交具体任务，任务通过socket获取输入输出流与客户端进行交互。   

有了数据流之后，开始想着定义数据结构，消息以何种格式在客户端和服务端进行识别呢。本着方便简介的目的，
直接采用IO流进行编码，好理解点直接使用DataObjectStream和DataInputStream对InputStream和OutPutStream进行装饰，
这两个API能很方便的直接将流读取成String或者将String写入流，然后进行二进制传输。
同时封装了Msg类作为数据最终要转换成的格式。

能与客户端进行交互后，开始想着设计用户体系，本着初版怎么轻量怎么来的原则，使用h2数据库。同时建立用户表。
有了用户之后，可以试着建立互相对话了。而不是服务器固定返回，服务器作一个中转，将数据转发给对应的用户。
同时，也不可能免登录就开始对话，所以相互对话前得先获取身份且登录。做个简单的逻辑即可，定义Msg的code 201为登录消息。服务器进行处理。
同时，Msg对象也需要调整，升级为EnhanceMsg
> 注意项

* 由于socket是阻塞io，所以单线程中只能一个个阻塞获取连接。单线程处理连接数会造成连接瓶颈。
* 获取到socket链接后，由于做的是IM应用，所以要一直持有这个socket，不能主动释放掉，所以是长连接，所以这里每获取到一个连接又要开启新的线程去处理具体的数据处理。因为线程资源宝贵
  ，所以采用线程池处理。但是线程池要注意，因为线程池是达到核心线程数后会将其放入到队列中，队列满了才会扩大到最大核心线程数，所以假如连接数到达了核心线程数的时候，后续再进来的连接请求就会
  被放入队列，这部分如果处理中的线程一直不被释放的话，会一直阻塞在队列中。所以需要提前知晓这里的坑，但是因为如果一直无限开线程的话肯定会造成OOM，所以需要控制好这个阈值。目前只设置了100个线程。
* 采用了Data Input/Output Stream进行数据写入和写出的话，最终是个String格式，但是我最终是要转成Msg对象，所以这里相当于构造对象，然后将对象转换成String，然后写入io流，然后对端又将io流读取出String，
最终按某个格式又将String转换成Msg对象，这中间对象和String的互相转换其实是可以避免的，直接采用Object Input/Output Stream将对象直接序列化到数据流。避免了中间商转换。所以这里又引出了一层序列化的概念，
要序列化的对象必须要实现Serializable接口。
* socket在进行read和write的时候，如果连接没有断且没有数据，会一直阻塞在对应API中。


